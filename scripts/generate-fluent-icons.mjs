import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const ICONS_MD_URL = 'https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/icons_regular.md';
const BASE_URL = 'https://raw.githubusercontent.com/microsoft/fluentui-system-icons/main/';
const TARGET_SIZE = Number.parseInt(process.env.FLUENT_ICON_SIZE || '20', 10);
const CONCURRENCY = 12;

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, '..');
const outputFile = path.join(rootDir, 'src', 'ui', 'fluentIconsRegular.jsx');

const fetchText = async (url) => {
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`Failed to fetch ${url} (${res.status})`);
  }
  return res.text();
};

const toPascalCase = (name) => name
  .split('_')
  .filter(Boolean)
  .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
  .join('');

const sanitizeExportName = (baseName, used) => {
  let name = toPascalCase(baseName);
  if (/^[0-9]/.test(name)) {
    name = `Icon${name}`;
  }
  let candidate = name;
  let suffix = 2;
  while (used.has(candidate)) {
    candidate = `${name}${suffix}`;
    suffix += 1;
  }
  used.add(candidate);
  return candidate;
};

const extractSvgPaths = (svgText) => {
  const matches = svgText.match(/<path\b[^>]*>/g) || [];
  const paths = matches.map((match) => {
    const dMatch = match.match(/d="([^"]+)"/);
    if (!dMatch) return null;
    const fillRuleMatch = match.match(/fill-rule="([^"]+)"/);
    const clipRuleMatch = match.match(/clip-rule="([^"]+)"/);
    const entry = { d: dMatch[1] };
    if (fillRuleMatch) entry.fillRule = fillRuleMatch[1];
    if (clipRuleMatch) entry.clipRule = clipRuleMatch[1];
    if (!entry.fillRule && !entry.clipRule) return entry.d;
    return entry;
  }).filter(Boolean);
  return paths;
};

const parseTableRows = (markdown) => {
  const rows = markdown.split('\n').filter((line) => line.startsWith('|'));
  return rows.slice(2).map((line) => {
    const cells = line
      .split('|')
      .slice(1, -1)
      .map((cell) => cell.trim());
    if (cells.length < 4) return null;
    const [name, iconCell, , androidCell] = cells;
    if (!name || !iconCell || !androidCell) return null;
    const srcMatch = iconCell.match(/src="([^"]+)"/);
    if (!srcMatch) return null;
    const iconSrc = srcMatch[1].replace('?raw=true', '');
    const matches = [...androidCell.matchAll(/ic_fluent_([a-z0-9_]+)_(\d+)_regular/g)];
    const target = matches.find((match) => Number.parseInt(match[2], 10) === TARGET_SIZE);
    if (!target) return null;
    const baseName = target[1];
    const targetPath = iconSrc.replace(/_(\d+)_regular\.svg$/, `_${TARGET_SIZE}_regular.svg`);
    return { name, baseName, path: targetPath };
  }).filter(Boolean);
};

const run = async () => {
  if (!Number.isInteger(TARGET_SIZE) || TARGET_SIZE <= 0) {
    throw new Error('FLUENT_ICON_SIZE must be a positive integer.');
  }
  const markdown = await fetchText(ICONS_MD_URL);
  const rows = parseTableRows(markdown);
  if (rows.length === 0) {
    throw new Error(`No ${TARGET_SIZE}px regular icons found in icons_regular.md`);
  }

  const uniqueByBase = new Map();
  rows.forEach((row) => {
    if (!uniqueByBase.has(row.baseName)) uniqueByBase.set(row.baseName, row);
  });

  const queue = Array.from(uniqueByBase.values());
  const results = [];
  const failures = [];

  const worker = async () => {
    while (queue.length > 0) {
      const iconRow = queue.pop();
      if (!iconRow) return;
      const { baseName, path: iconPath } = iconRow;
      try {
        const svgText = await fetchText(`${BASE_URL}${iconPath}`);
        const paths = extractSvgPaths(svgText);
        if (paths.length === 0) {
          failures.push({ iconPath, reason: 'No <path> elements found' });
          continue;
        }
        results.push({ baseName, paths });
      } catch (error) {
        failures.push({ iconPath, reason: error.message });
      }
    }
  };

  await Promise.all(Array.from({ length: CONCURRENCY }, () => worker()));

  if (failures.length > 0) {
    console.warn(`Warning: ${failures.length} icons could not be parsed.`);
  }

  const usedNames = new Set();
  const mapped = results
    .map((entry) => ({
      exportName: sanitizeExportName(entry.baseName, usedNames),
      paths: entry.paths
    }))
    .sort((a, b) => a.exportName.localeCompare(b.exportName));

  const lines = [];
  lines.push('// This file is auto-generated by scripts/generate-fluent-icons.mjs');
  lines.push(`// Source: icons_regular.md (${TARGET_SIZE}px regular).`);
  lines.push("// Do not edit this file directly.");
  lines.push("import React from 'react';");
  lines.push('');
  lines.push('export const createIcon = (paths) => (props) => {');
  lines.push('  const size = props.size || 24;');
  lines.push('  const className = props.className || \'\';');
  lines.push('  return (');
  lines.push('    <svg');
  lines.push('      width={size}');
  lines.push('      height={size}');
  lines.push(`      viewBox="0 0 ${TARGET_SIZE} ${TARGET_SIZE}"`);
  lines.push('      fill="currentColor"');
  lines.push('      className={className}');
  lines.push('      aria-hidden="true"');
  lines.push('    >');
  lines.push('      {Array.isArray(paths)');
  lines.push('        ? paths.map((entry, index) => {');
  lines.push('          if (typeof entry === \'string\') return <path key={index} d={entry} />;');
  lines.push('          const { d, fillRule, clipRule } = entry;');
  lines.push('          return (');
  lines.push('            <path');
  lines.push('              key={index}');
  lines.push('              d={d}');
  lines.push('              {...(fillRule ? { fillRule } : {})}');
  lines.push('              {...(clipRule ? { clipRule } : {})}');
  lines.push('            />');
  lines.push('          );');
  lines.push('        })');
  lines.push('        : <path d={paths} />}');
  lines.push('    </svg>');
  lines.push('  );');
  lines.push('};');
  lines.push('');

  mapped.forEach(({ exportName, paths }) => {
    lines.push(`export const ${exportName} = createIcon(${JSON.stringify(paths)});`);
  });

  lines.push('');
  lines.push('export const fluentIconsRegular = {');
  mapped.forEach(({ exportName }) => {
    lines.push(`  ${exportName},`);
  });
  lines.push('};');
  lines.push('');

  await fs.writeFile(outputFile, lines.join('\n') + '\n', 'utf8');

  console.log(`Generated ${mapped.length} icons to ${outputFile}`);
};

run().catch((error) => {
  console.error(error);
  process.exit(1);
});
